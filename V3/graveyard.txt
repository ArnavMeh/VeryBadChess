// 00 01 02 03 04 05 06 07
// 08 09 10 11 12 13 14 15
// 16 17 18 19 20 21 22 23
// 24 25 26 27 28 29 30 31
// 32 33 34 35 36 37 38 39
// 40 41 42 43 44 45 46 47
// 48 49 50 51 52 53 54 55
// 56 57 58 59 60 61 62 63


    template<class Color>
    inline MoveScore nega_max_eval(
        Board& b,
        Context& new_ctx,
        U16 depth,
        I16 alpha,
        I16 beta
    );
    template<class Color>
    inline MoveScore nega_max_eval(
        Board& b,
        Context& new_ctx,
        U16 depth,
        I16 alpha,
        I16 beta
    ) {
        constexpr bool turn = std::is_same<Color, White>::value;

        U64* cell = TranspositionTable::get_cell(new_ctx.hash, depth);

        // TT hit: use eval and/or move of cached result.
        if (cell) {
            if (TranspositionTable::get_depth(cell) >= depth) {
                tt_hits++;

                return TranspositionTable::get_eval_move(cell);
            }
            else {
                tt_partials++;

                Move next_order_first = TranspositionTable::get_move(cell);
                MoveScore local_best = (
                    turn ? nega_max<Black>(b, new_ctx, depth - 1, next_order_first, -beta, -alpha)
                         : nega_max<White>(b, new_ctx, depth - 1, next_order_first, -beta, -alpha)
                );
                local_best.eval *= -1;

                TranspositionTable::get_eval(cell) = local_best.eval;
                TranspositionTable::get_move(cell) = local_best.move;
                return local_best;
            }
        }

        // TT miss: compute fully and set.
        tt_misses++;

        MoveScore local_best = (
            turn ? nega_max<Black>(b, new_ctx, depth - 1, Move(), -beta, -alpha)
                 : nega_max<White>(b, new_ctx, depth - 1, Move(), -beta, -alpha)
        );
        local_best.eval *= -1;

        TranspositionTable::set_cell(new_ctx.hash, depth, local_best.move, local_best.eval, 0);
        return local_best;
    }


// bool turn;
    // Context ctx = b.from_fen("startpos", turn);
    // b.print();
    // cout << hex << ctx.hash << "\n";

    // play_moves(
    //     "e2e4",
    //     b, ctx, turn
    // );

    // play_moves(
    //     "e2e4 c7c5 f1e2 b8c6 b1c3 e7e6 g1f3 g8f6 d2d3 d7d5 e4e5 f6d7 c1f4 d5d4 c3e4 c5c4 e1g1 c4d3 e2d3 h7h6 d3b5 d8b6 b5c6 b6b2 a1b1 b2b1 c6d7 e8e7",
    //     b, ctx, turn
    // );
    // cout << hex << ctx.hash << "\n";

    // Perft::run<White>(b, ctx, 3); // , "tests/perft_solution.txt"

    // bool turn = true;
    
    // while (true) {
        // time_fn([turn, ctx]() {

        //     Context _ctx = ctx;
        //     auto [ eval, move ] = turn ? Search::search<White>(b, _ctx, 8)
        //                                : Search::search<Black>(b, _ctx, 8);

        //     cout << "EVAL: " << eval << '\n';
        //     move.print();
        //     cout << '\n';

        //     // if (turn) b.do_move<White>(Search::best_move, _ctx);
        //     // else      b.do_move<Black>(Search::best_move, _ctx);

        //     cout << "Branches:\t"       << Search::branches  << '\n';
        //     cout << "BF:\t\t"           << Search::branches / (Search::nodes + 0.0) << '\n';
        //     cout << '\n';
        //     cout << "TT Hits:\t"        << Search::tt_hits     << '\n';
        //     cout << "TT Partials:\t"    << Search::tt_partials << '\n';
        //     cout << "TT Misses:\t"      << Search::tt_misses   << '\n';
        //     cout << '\n';
        //     cout << "Killer Entries:\t" << KillerTable::fill << '\n';
        //     cout << "Killer Hits:\t"    << KillerTable::hits << '\n';
        //     cout << "Killer Misses:\t"  << KillerTable::misses << '\n';
        //     cout << '\n';
        //     // cout << "TTHR: " << Search::tt_hits / (Search::branches + 0.0) << '\n';
        // });
        // turn = !turn;
    // }
    
    // perft<White>(b, 6);

    // U64 cells[2] = {};
    // cout << hex << cells[0] << ' ' << hex << cells[1] << '\n';
    // U16* arr = (U16*)cells;
    // arr[0] = 0xffff;
    // cout << hex << cells[0] << ' ' << hex << cells[1];
    // [ 3210, 7654 ]
    // [ 10, 32 ]
    // [ 0, 1 ]

    ----------------------------------------------

    // perft<White>(b, depth, "t.txt");

    // CLI(INITIAL_FEN);
    // CLI("rnbqkb1r/pppppppp/7n/8/8/3P4/PPP1PPPP/RNBQKBNR w KQkq - 0 1");
    // CLI("rnbqkbnr/p1pppppp/8/8/8/2PPPP2/PpNQKPPP/R1B2BNR b HAkq - 0 1");
    // CLI("rn1qk2r/ppPbpppp/5bn1/4pp2/8/1NB2BN1/PPPQPPPP/R3K2R w KQkq - 0 1");
    // CLI("r3k2r/ppnbpppp/3q1bn1/4pp2/8/1NB2BN1/PPPQPPPP/R3K2R b KQkq - 0 1");  

    // Board b2;
    // b2.from_fen(INITIAL_FEN);
    // perft(b2, 4);

    // b.assert_board_consistency();
    // b.print();

    // MoveList ml = MoveList();
    // b.gen_moves(ml);
    // ml.print();

    // auto start = std::chrono::system_clock::now();
    // U64 N = 10000000000;
    // for (U64 i = 0; i < N; i++) {
    //     Move m1 = Move::from<Flag::PAWN_DOUBLE, Piece::NA>(Piece::NA, 0, 35);
    //     b.do_move<White>(m1);
    //     b.undo_move<White>(m1);
    // }
    // auto end = std::chrono::system_clock::now();
    // std::chrono::duration<double> t_sec = end - start;
    // cout << (N / (t_sec.count() * 1000.0)) << " Kn/S\n";

    // 1B / 3.6S
    // MAX ACHIEVABLE: ~280,000 Kn/S

    // b.print();

    // template<class Color>
// void Board::gen_moves<Gen::LEGALS>(MoveList &moves) {
//     int checks = pop_count(this->get_checks());
//     U64 pins = this->get_pins<Color>();

//     if (checks) {
//         // singles, doubles, promos, captures, promo-captures
//         this->gen_pawn_moves  <Color, Gen::EVASIONS>(moves);

//         this->gen_knight_moves<Color, Gen::EVASIONS>(moves);
//         this->gen_king_moves  <Color, Gen::EVASIONS>(moves);

//         this->gen_queen_moves <Color, Gen::EVASIONS>(moves);
//         this->gen_rook_moves  <Color, Gen::EVASIONS>(moves);
//         this->gen_bishop_moves<Color, Gen::EVASIONS>(moves);

//     } else {
//         // singles, doubles, promos, captures, promo-captures
//         this->gen_pawn_moves  <Color, Gen::NON_EVASIONS>(moves);

//         this->gen_knight_moves<Color, Gen::NON_EVASIONS>(moves);
//         this->gen_king_moves  <Color, Gen::NON_EVASIONS>(moves);

//         this->gen_queen_moves <Color, Gen::NON_EVASIONS>(moves);
//         this->gen_rook_moves  <Color, Gen::NON_EVASIONS>(moves);
//         this->gen_bishop_moves<Color, Gen::NON_EVASIONS>(moves);
        
//         this->gen_castle<Color, typename Color::OO>(moves);
//         this->gen_castle<Color, typename Color::OOO>(moves);
//     }
// }

// if constexpr (Gn == Gen::BLOCKS) {
    //     U64 checks = this->get_checks<Color>();
    //     U64 filter = this->get_check_blocks<Color>(checks);
    //     this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter);
    //     this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter);
    // }

    // if constexpr (Gn == Gen::LEGALS) {
    //     U64 checks = this->get_checks<Color>();
    //     int num_checks = pop_count(checks);

    //     switch (num_checks) {
    //         case 0: { // filter on from sqs
    //             U64 pins = this->get_pins<Color>();
    //             U64 filter1 = ~pins; // moveable with worrying about legality
    //             U64 filter2 = pins; // brute force on this.
    //             this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter2);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter2);
    //             this->gen_piece_moves<Color, Flag::QUIET,   Color::KING>(moves, this->get_bitboard(Color::ALL));
    //             this->gen_piece_moves<Color, Flag::CAPTURE, Color::KING>(moves, this->get_bitboard(Color::OPP_ALL));
    //             {
    //                 int& len = moves.size();
    //                 for (int i = 0; i < moves.size(); i++) {
    //                     this->do_move<Color>(moves[i]);
    //                     bool was_illegal = this->get_checks<Color>() != 0ULL;
    //                     this->undo_move<Color>(moves[i]);
    //                     if (was_illegal) {
    //                         moves[i--] = moves[--len];
    //                     }
    //                 }
    //             }
    //             this->gen_moves_with_filter<Color, Gen::QUIETS  , false>(moves, filter1);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter1);
    //             this->gen_castle<Color, typename Color::OO >(moves);
    //             this->gen_castle<Color, typename Color::OOO>(moves);
    //             break;
    //         }
    //         case 1: { // filter on to_sqs
    //             U64 pins = this->get_pins<Color>();
    //             U64 check_blocks = this->get_check_blocks<Color>(this->get_checks<Color>());
    //             U64 filter = check_blocks & ~pins; // not on kings
    //             this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter);
    //             break;
    //         }
    //         case 2: {
    //             // brute force on king moves. degenerate case.
    //             this->gen_piece_moves<Color, Flag::QUIET,   Color::KING>(moves, this->get_bitboard(Color::ALL));
    //             this->gen_piece_moves<Color, Flag::CAPTURE, Color::KING>(moves, this->get_bitboard(Color::OPP_ALL));
    //             {
    //                 int& len = moves.size();
    //                 for (int i = 0; i < moves.size(); i++) {
    //                     this->do_move<Color>(moves[i]);
    //                     bool was_illegal = this->get_checks<Color>() != 0ULL;
    //                     this->undo_move<Color>(moves[i]);
    //                     if (was_illegal) {
    //                         moves[i--] = moves[--len];
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }


U64 hmap_err1 = 0;
U64 hmap_err2 = 0;
std::unordered_map<U64, U16> hmap;

// simulate 0-miss table
// bool is_true_hit = hmap.find(new_ctx.hash) != hmap.end()
//                 && hmap[new_ctx.hash] >= depth;
// hmap_err1 += is_true_hit && !(cell != nullptr);
// hmap_err2 += !is_true_hit && (cell != nullptr);
// if (hmap.find(new_ctx.hash) != hmap.end()) {
//     hmap.insert({ new_ctx.hash, depth });
// } else {
//     hmap[new_ctx.hash] = std::max(hmap[new_ctx.hash], depth);
// }

cout << "TT ER1 (undrshoot): " << Search::hmap_err1 / (Search::branches + 0.0) << '\n';
            cout << "TT ER2 (overshoot): " << Search::hmap_err2 / (Search::branches + 0.0) << '\n';
            

// template<class Color>
    // int quiscence(Board &b, int alpha, int beta) {
    //     constexpr bool turn = std::is_same<Color, White>::value;
        
    //     MoveList ml; b.gen_moves<Color, Gen::CAPTURES>(ml);
    //     ml.sort();
        
    //     int eval = -INFINITY;
    //     int legal_caps = 0;

    //     for (int i = 0; i < ml.size(); i++) {
    //         b.do_move<Color>(ml[i], ctx);

    //         if (b.get_checks<Color>() == 0ULL) { // filter out illegal moves
    //             legal_caps++;

    //             int temp_eval = turn ? -quiscence<Black>(b, -beta, -alpha)
    //                                  : -quiscence<White>(b, -beta, -alpha);
    //             eval = std::max(eval, temp_eval);
    //             alpha = std::max(alpha, eval);
    //         }

    //         b.undo_move<Color>(ml[i]);
    //         if (alpha >= beta) break;
    //     }

    //     if (legal_caps == 0) {
    //         return turn ? Evaluate::piece_val(b) : -Evaluate::piece_val(b);
    //     }

    //     return eval;
    // }