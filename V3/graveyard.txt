// 00 01 02 03 04 05 06 07
// 08 09 10 11 12 13 14 15
// 16 17 18 19 20 21 22 23
// 24 25 26 27 28 29 30 31
// 32 33 34 35 36 37 38 39
// 40 41 42 43 44 45 46 47
// 48 49 50 51 52 53 54 55
// 56 57 58 59 60 61 62 63


    // perft<White>(b, depth, "t.txt");

    // CLI(INITIAL_FEN);
    // CLI("rnbqkb1r/pppppppp/7n/8/8/3P4/PPP1PPPP/RNBQKBNR w KQkq - 0 1");
    // CLI("rnbqkbnr/p1pppppp/8/8/8/2PPPP2/PpNQKPPP/R1B2BNR b HAkq - 0 1");
    // CLI("rn1qk2r/ppPbpppp/5bn1/4pp2/8/1NB2BN1/PPPQPPPP/R3K2R w KQkq - 0 1");
    // CLI("r3k2r/ppnbpppp/3q1bn1/4pp2/8/1NB2BN1/PPPQPPPP/R3K2R b KQkq - 0 1");  

    // Board b2;
    // b2.from_fen(INITIAL_FEN);
    // perft(b2, 4);

    // b.assert_board_consistency();
    // b.print();

    // MoveList ml = MoveList();
    // b.gen_moves(ml);
    // ml.print();

    // auto start = std::chrono::system_clock::now();
    // U64 N = 10000000000;
    // for (U64 i = 0; i < N; i++) {
    //     Move m1 = Move::from<Flag::PAWN_DOUBLE, Piece::NA>(Piece::NA, 0, 35);
    //     b.do_move<White>(m1);
    //     b.undo_move<White>(m1);
    // }
    // auto end = std::chrono::system_clock::now();
    // std::chrono::duration<double> t_sec = end - start;
    // cout << (N / (t_sec.count() * 1000.0)) << " Kn/S\n";

    // 1B / 3.6S
    // MAX ACHIEVABLE: ~280,000 Kn/S

    // b.print();

    // template<class Color>
// void Board::gen_moves<Gen::LEGALS>(MoveList &moves) {
//     int checks = pop_count(this->get_checks());
//     U64 pins = this->get_pins<Color>();

//     if (checks) {
//         // singles, doubles, promos, captures, promo-captures
//         this->gen_pawn_moves  <Color, Gen::EVASIONS>(moves);

//         this->gen_knight_moves<Color, Gen::EVASIONS>(moves);
//         this->gen_king_moves  <Color, Gen::EVASIONS>(moves);

//         this->gen_queen_moves <Color, Gen::EVASIONS>(moves);
//         this->gen_rook_moves  <Color, Gen::EVASIONS>(moves);
//         this->gen_bishop_moves<Color, Gen::EVASIONS>(moves);

//     } else {
//         // singles, doubles, promos, captures, promo-captures
//         this->gen_pawn_moves  <Color, Gen::NON_EVASIONS>(moves);

//         this->gen_knight_moves<Color, Gen::NON_EVASIONS>(moves);
//         this->gen_king_moves  <Color, Gen::NON_EVASIONS>(moves);

//         this->gen_queen_moves <Color, Gen::NON_EVASIONS>(moves);
//         this->gen_rook_moves  <Color, Gen::NON_EVASIONS>(moves);
//         this->gen_bishop_moves<Color, Gen::NON_EVASIONS>(moves);
        
//         this->gen_castle<Color, typename Color::OO>(moves);
//         this->gen_castle<Color, typename Color::OOO>(moves);
//     }
// }

// if constexpr (Gn == Gen::BLOCKS) {
    //     U64 checks = this->get_checks<Color>();
    //     U64 filter = this->get_check_blocks<Color>(checks);
    //     this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter);
    //     this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter);
    // }

    // if constexpr (Gn == Gen::LEGALS) {
    //     U64 checks = this->get_checks<Color>();
    //     int num_checks = pop_count(checks);

    //     switch (num_checks) {
    //         case 0: { // filter on from sqs
    //             U64 pins = this->get_pins<Color>();
    //             U64 filter1 = ~pins; // moveable with worrying about legality
    //             U64 filter2 = pins; // brute force on this.
    //             this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter2);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter2);
    //             this->gen_piece_moves<Color, Flag::QUIET,   Color::KING>(moves, this->get_bitboard(Color::ALL));
    //             this->gen_piece_moves<Color, Flag::CAPTURE, Color::KING>(moves, this->get_bitboard(Color::OPP_ALL));
    //             {
    //                 int& len = moves.size();
    //                 for (int i = 0; i < moves.size(); i++) {
    //                     this->do_move<Color>(moves[i]);
    //                     bool was_illegal = this->get_checks<Color>() != 0ULL;
    //                     this->undo_move<Color>(moves[i]);
    //                     if (was_illegal) {
    //                         moves[i--] = moves[--len];
    //                     }
    //                 }
    //             }
    //             this->gen_moves_with_filter<Color, Gen::QUIETS  , false>(moves, filter1);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter1);
    //             this->gen_castle<Color, typename Color::OO >(moves);
    //             this->gen_castle<Color, typename Color::OOO>(moves);
    //             break;
    //         }
    //         case 1: { // filter on to_sqs
    //             U64 pins = this->get_pins<Color>();
    //             U64 check_blocks = this->get_check_blocks<Color>(this->get_checks<Color>());
    //             U64 filter = check_blocks & ~pins; // not on kings
    //             this->gen_moves_with_filter<Color, Gen::QUIETS,   false>(moves, filter);
    //             this->gen_moves_with_filter<Color, Gen::CAPTURES, false>(moves, filter);
    //             break;
    //         }
    //         case 2: {
    //             // brute force on king moves. degenerate case.
    //             this->gen_piece_moves<Color, Flag::QUIET,   Color::KING>(moves, this->get_bitboard(Color::ALL));
    //             this->gen_piece_moves<Color, Flag::CAPTURE, Color::KING>(moves, this->get_bitboard(Color::OPP_ALL));
    //             {
    //                 int& len = moves.size();
    //                 for (int i = 0; i < moves.size(); i++) {
    //                     this->do_move<Color>(moves[i]);
    //                     bool was_illegal = this->get_checks<Color>() != 0ULL;
    //                     this->undo_move<Color>(moves[i]);
    //                     if (was_illegal) {
    //                         moves[i--] = moves[--len];
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }


U64 hmap_err1 = 0;
U64 hmap_err2 = 0;
std::unordered_map<U64, U16> hmap;

// simulate 0-miss table
// bool is_true_hit = hmap.find(new_ctx.hash) != hmap.end()
//                 && hmap[new_ctx.hash] >= depth;
// hmap_err1 += is_true_hit && !(cell != nullptr);
// hmap_err2 += !is_true_hit && (cell != nullptr);
// if (hmap.find(new_ctx.hash) != hmap.end()) {
//     hmap.insert({ new_ctx.hash, depth });
// } else {
//     hmap[new_ctx.hash] = std::max(hmap[new_ctx.hash], depth);
// }

cout << "TT ER1 (undrshoot): " << Search::hmap_err1 / (Search::branches + 0.0) << '\n';
            cout << "TT ER2 (overshoot): " << Search::hmap_err2 / (Search::branches + 0.0) << '\n';
            

// template<class Color>
    // int quiscence(Board &b, int alpha, int beta) {
    //     constexpr bool turn = std::is_same<Color, White>::value;
        
    //     MoveList ml; b.gen_moves<Color, Gen::CAPTURES>(ml);
    //     ml.sort();
        
    //     int eval = -INFINITY;
    //     int legal_caps = 0;

    //     for (int i = 0; i < ml.size(); i++) {
    //         b.do_move<Color>(ml[i], ctx);

    //         if (b.get_checks<Color>() == 0ULL) { // filter out illegal moves
    //             legal_caps++;

    //             int temp_eval = turn ? -quiscence<Black>(b, -beta, -alpha)
    //                                  : -quiscence<White>(b, -beta, -alpha);
    //             eval = std::max(eval, temp_eval);
    //             alpha = std::max(alpha, eval);
    //         }

    //         b.undo_move<Color>(ml[i]);
    //         if (alpha >= beta) break;
    //     }

    //     if (legal_caps == 0) {
    //         return turn ? Evaluate::piece_val(b) : -Evaluate::piece_val(b);
    //     }

    //     return eval;
    // }